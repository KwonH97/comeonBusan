<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>부산 여행 AI 맞춤 일정</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            margin-top: 80px; /* 헤더와 겹치지 않도록 여백 추가 */
            background-color: #f5f5f5;
        }
        #map {
            height: 470px;
            width: 90%;
            margin: 0 auto; /* 가운데 정렬 */
            margin-bottom: 30px;
        }
        .loading {
            display: none;
        }
        .table-responsive {
            overflow-x: auto;
        }
        .table th, .table td {
            text-align: center;
            vertical-align: middle;
        }
        .gm-style-iw {
            padding: 10px;
        }
        .gm-style-iw h3 {
            margin-top: 0;
            color: #333;
        }
        .gm-style-iw p {
            margin: 5px 0;
            color: #666;
        }
    </style>
</head>
<body>
<header>
    <th:block th:insert="~{/fragments/header2.html}"></th:block>
</header>
    <div class="container mt-5">
        <h1 class="mb-4">부산 여행 AI 맞춤 일정</h1>
        <form id="planner-form">
            <div class="row mb-3">
                <div class="col-md-6">
                    <label for="start-date" class="form-label">여행 시작 날짜:</label>
                    <input type="date" id="start-date" class="form-control" required>
                </div>
                <div class="col-md-6">
                    <label for="end-date" class="form-label">여행 종료 날짜:</label>
                    <input type="date" id="end-date" class="form-control" required>
                </div>
            </div>
            <div class="row mb-3">
                <div class="col-md-4">
                    <label for="travel-type" class="form-label">여행 형태:</label>
                    <select id="travel-type" class="form-select">
                        <option value="activity">액티비티</option>
                        <option value="history">역사</option>
                        <option value="food">맛집</option>
                    </select>
                </div>
                <div class="col-md-4">
                    <label for="budget" class="form-label">예산 (원):</label>
                    <input type="number" id="budget" class="form-control" min="0" step="10000">
                </div>
                <div class="col-md-4">
                    <label for="transportation" class="form-label">교통 수단:</label>
                    <select id="transportation" class="form-select">
                        <option value="public">대중교통</option>
                        <option value="car">자동차</option>
                        <option value="walk">도보</option>
                    </select>
                </div>
            </div>
            <button type="submit" class="btn btn-primary">추천 여행 일정 생성</button>
        </form>

        <div class="mt-4 loading">
            <div class="d-flex justify-content-center">
                <div class="spinner-border" role="status">
                    <span class="visually-hidden">로딩중...</span>
                </div>
            </div>
        </div>

        <div id="result" class="mt-4"></div>
        <div id="map" class="mt-4"></div>
    </div>
  <footer>
    <th:block th:insert="~{/fragments/footer.html}"></th:block>
  </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB1VqsvOxs4dsglMk3wCxxB-_y58G3zyzU&callback=initMap" async defer></script>
    <script src="https://code.jquery.com/jquery-3.7.1.js"
        integrity="sha256-eKhayi8LEQwp4NKxN+CfCh+3qOVUtJn3QNZ0TciWLP4="
        crossorigin="anonymous"></script>
    <script>
        let map;
        let markers = [];
        let polylines = [];

        function initMap() {
            map = new google.maps.Map(document.getElementById('map'), {
                center: {lat: 35.1796, lng: 129.0756},
                zoom: 12
            });
        }

        function getFormattedDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function setMinDate() {
            const today = new Date();
            const formattedDate = getFormattedDate(today);
            document.getElementById('start-date').setAttribute('min', formattedDate);
            document.getElementById('end-date').setAttribute('min', formattedDate);
        }

        async function fetchWeatherData(startDate, endDate) {
            const cityName = 'Busan';
            const url = `/proxy/weather-api?q=${cityName}&units=metric`;
            const response = await fetch(url);
            const data = await response.json();
            return data.list.filter(item => {
                const itemDate = new Date(item.dt * 1000);
                return itemDate >= startDate && itemDate <= endDate;
            }).map(item => ({
                date: new Date(item.dt * 1000).toISOString().split('T')[0],
                weather: item.weather[0].description,
                temp: item.main.temp
            }));
        }

        async function fetchOpenAI(prompt) {
            const apiKey = '';
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: 'gpt-3.5-turbo',
                    messages: [{"role": "user", "content": prompt}]
                })
            });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            return data.choices[0].message.content.trim();
        }

        function displayAIResponse(response) {
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = `<pre>${response}</pre>`;
        }

        function parseItinerary(itinerary) {
            const lines = itinerary.split('\n');
            const days = {};
            let currentDate = '';

            lines.forEach(line => {
                const dateMatch = line.match(/^(\d{4}-\d{2}-\d{2}):/);
                if (dateMatch) {
                    currentDate = dateMatch[1];
                    if (!days[currentDate]) {
                        days[currentDate] = [];
                    }
                } else {
                    const match = line.match(/(\d{2}:\d{2}): (.+) \((\d+\.\d+),\s*(\d+\.\d+)\) \| (.+) \| (.+) \| (.+)/);
                    if (match && currentDate) {
                        const [_, time, name, lat, lng, activity, cost, weather] = match;
                        days[currentDate].push({
                            time: time,
                            name: name,
                            lat: parseFloat(lat),
                            lng: parseFloat(lng),
                            activity: activity,
                            cost: cost,
                            weather: weather
                        });
                    }
                }
            });

            console.log("Parsed itinerary:", days);
            return days;
        }

        function getColor(index) {
            const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
            return colors[index % colors.length];
        }

        function drawMarkersAndPolylines(days) {
            console.log("Drawing markers and polylines:", days);
            // 기존 마커와 선 제거
            markers.forEach(marker => marker.setMap(null));
            markers = [];
            polylines.forEach(polyline => polyline.setMap(null));
            polylines = [];

            let dayIndex = 0;

            for (const date in days) {
                const color = getColor(dayIndex);
                const places = days[date];

                const bounds = new google.maps.LatLngBounds();
                const path = places.map((place, index) => {
                    const latLng = new google.maps.LatLng(place.lat, place.lng);
                    bounds.extend(latLng);

                    const marker = new google.maps.Marker({
                        position: latLng,
                        map: map,
                        title: place.name,
                        animation: google.maps.Animation.DROP,
                        label: {
                            text: (index + 1).toString(),
                            color: 'white'
                        },
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 10,
                            fillColor: color,
                            fillOpacity: 1,
                            strokeColor: 'white',
                            strokeWeight: 2
                        }
                    });

                    const infowindow = new google.maps.InfoWindow({
                        content: `<div>
                            <h3>${place.name}</h3>
                            <p>시간: ${place.time}</p>
                            <p>활동: ${place.activity}</p>
                            <p>비용: ${place.cost}</p>
                            <p>날씨: ${place.weather}</p>
                        </div>`
                    });

                    marker.addListener('click', () => {
                        infowindow.open(map, marker);
                    });

                    markers.push(marker);

                    return latLng;
                });

                // 선 그리기
                const polyline = new google.maps.Polyline({
                    path: path,
                    geodesic: true,
                    strokeColor: color,
                    strokeOpacity: 1.0,
                    strokeWeight: 2
                });
                polyline.setMap(map);
                polylines.push(polyline);

                // 지도 범위 조정
                map.fitBounds(bounds);
                dayIndex++;
            }
        }

        document.getElementById('planner-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const loadingDiv = document.querySelector('.loading');
            loadingDiv.style.display = 'block';

            const startDate = new Date(document.getElementById('start-date').value);
            const endDate = new Date(document.getElementById('end-date').value);
            const travelType = document.getElementById('travel-type').value;
            const budget = document.getElementById('budget').value;
            const transportation = document.getElementById('transportation').value;

            try {
                const weatherData = await fetchWeatherData(startDate, endDate);
                const weatherSummary = weatherData.map(item => 
                    `Date: ${item.date}, Weather: ${item.weather}, Temperature: ${item.temp}°C`
                ).join('\n');

                const prompt = `다음은 부산 여행 일정 계획에 필요한 정보입니다.
                - 여행 시작 날짜: ${getFormattedDate(startDate)}
                - 여행 종료 날짜: ${getFormattedDate(endDate)}
                - 여행 형태: ${travelType}
                - 예산: ${budget}원
                - 교통 수단: ${transportation}
                - 날씨 요약: ${weatherSummary}

                위 정보를 바탕으로 매일 추천 시간과 일정을 만들어 주세요. 
                각 장소에 대해 사용자가 입력한 각 날짜 별로 다음 형식으로 응답해주세요:
                YYYY-MM-DD:
                시간: <장소명> (위도, 경도) | 활동 설명 | 예상 비용 | 날씨
                예: 
                2024-07-20:
                10:00: 부산타워 (35.1796, 129.0756) | 전망대 관람 | 10,000원 | 맑음`;

                const itinerary = await fetchOpenAI(prompt);
                displayAIResponse(itinerary);  // AI의 답변을 먼저 출력
                const days = parseItinerary(itinerary);
                if (Object.keys(days).length > 0) {
                    drawMarkersAndPolylines(days);  // 추출된 장소로 지도에 마커를 표시하고 경로를 그림
                } else {
                    console.error("No valid places found in the itinerary.");
                }

            } catch (error) {
                document.getElementById('result').innerHTML = `<div class="alert alert-danger">오류: ${error.message}</div>`;
            } finally {
                loadingDiv.style.display = 'none';
            }
        });

        document.addEventListener('DOMContentLoaded', setMinDate);
    </script>
</body>
</html>
